## 回答

 `^(a|aa)+$` といった正規表現が`"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"`といった文字列にマッチするか調べようとすると、非常に膨大な時間がかかる。

 現代の正規表現は先読みなどの機能を提供するために多くが非決定性有限オートマトン (NFA) によって実装されているが、そこで用いられるバックトラックというアルゴリズムによって上記のパターンのマッチは非常に時間がかかるらしい。


## 正規表現の実装による差異

> これは、正規表現エンジンには大きく分けて2種類の実装があることが関係しています。
つまり、 決定性有限オートマトン (DFA) と 非決定性有限オートマトン (NFA) です。

>一般に DFA を用いた正規表現の実装では、正規表現の実行にかかる時間計算量は入力文字列の長さに対して線形であり、この記事で扱っているような問題とは無縁です。
上で例示した egrep コマンドは DFA による正規表現の実装が行われているため、正規表現の実行が極端に重くなることを回避できています。
一方で、 DFA では正規表現の先読みや後読み、最短一致のような拡張的な機能を実現することができません。

> 現代のプログラミング言語では、正規表現に先読みなどの機能が提供されることは一般的となっていますから、多くの言語で NFA を用いた正規表現の実装が行われていると考えてよいでしょう。4
NFA を利用した実装では、バックトラックという方式によって正規表現のマッチ処理が行われており、これが本記事で扱う問題について大きく関わってくることになります。

## バックトラック

> 正しい結果が得られなかった場合に少し処理を巻き戻して別のパターンを試していくアルゴリズム。

以下の特徴がある
> - 入力された文字列の先頭から順にパターンに一致するか調べていく
> - パターンに一致するか調べるときは、正規表現の先頭から順にパターンに当てはまるか調べる
> - 繰り返しがある場合はできるだけ長くとり、その後のパターンで失敗したら戻ってきて一文字短くしてやり直す
> - 正規表現のパターンの末尾まで一致したら、その時点で成功とする
    - (最後まで試行して一致することがなかった場合には失敗となる)

> おおむね愚直に再帰を書いて実装したらそうなるだろう、と考えられるような挙動そのままなので、深さ優先探索のようなアルゴリズムに慣れていると雰囲気をつかみやすい



引用・参考:[正規表現をフリーズさせないために](https://qiita.com/Tatamo/items/68a10c6274953e695354)