## i1

42が出力された後100が出力された。

理由: Promise.anyでは最初に解決されたものをPromiseの値として返すため、最初にvにPromiseの値として返された42が代入され、log(v)では42が出力される。次に、await wait2によって2秒経過したことでPromise.any中の.then(() => (v = 100))が完了し、vに100が代入される。よって、2回目のlog(v)では100が出力される。

## i2

1秒後にC, その1秒後にB, その1秒後にA, それとほぼ同時に[ 'A', 'B', 'C' ]という順で出力された。

理由: Promise.all中の処理が非同期に実行され、waitの秒数が短い順にlogC, logB, logAが実行される。すべてのPromiseが解決すると、それらの結果を含む配列が返され、vに代入される。

## i3

1秒後にY、その直後に42が出力され、その1秒後にB、その2秒後に0が出力された。

理由: Promise.all中の処理が1つでも失敗した時点でPromise.allは直ちにそのエラーで失敗する。したがって、1秒後にerrYが発生するとただちにcatchブロックに移動し、初期値のv=42が出力される。その1秒後にlogBによってBが出力され、そのさらに1秒後にv=0によってvの値が更新されるため、lov(v)で0が出力される。

## i4

5秒後に0, その4秒後に1...と5-秒数が出力値になるような間隔で数値が出力され、最後にCOMPLETE Dが表示された。

理由: forループで直列に実行しているため。

## i5

ただちにCOMPLETEDが表示され、その1秒後に4, その1秒後に3...という順で出力されてしまった。

理由: Promiseのthenメソッドに関数ではなく直接Promiseを返す式を渡してしまているため、forループが実行される際にwait関数が即時に呼び出され、すべてのPromiseが同時に実行されてしまうから。

## i6

1秒後に4, その1秒後に3...という順で出力され、最後にCOMPLETEDが出力された。

理由: Promise.allを使用しているため、配列[0, 1, 2, 3, 4]の各要素に対してwait((5 - i) \* 1000)の呼び出しは、map関数によってほぼ同時に行われ、すべてのPromiseが解決した後にthenメソッド内のlog("COMPLETED")が実行されるため。

## i7

11秒後に10が出力された。

理由: p1とp2が並列して実行されるため、vの値は10回+1されて10になる。p1の方は最初にwait1がある分1秒処理が遅いため、11秒後にPromise.allが解決してそれからv=10が出力される。

## i8

11秒後に5が出力された。

理由: 読み込みと書き込みの間に待機が生じることで、片方が値を更新した際にもう片方が更新後の値ではなく古い値に対して更新を行なってしまうため(以下図解参照)

```
図解
             読(0)    　書(1)読(1)   　書(2)読(2)    書(3)読(3)   　書(4)読(4)   　　書(5)
     wait1  wait2       wait2      wait2       wait2       wait2
 p1  |------||------------||------------||------------||------------||------------|

     読(0)　 　書(1)読(1)   　　書(2)読(2)   書(3)読(3)   　　書(4)読(4)    　書(5)
     wait2      wait2       wait2       wait2        wait2
 p1  |------------||------------||------------||------------||------------|

     0            1             2             3             4             5
 v   |------------|-------------|-------------|-------------|-------------|------>|
```
