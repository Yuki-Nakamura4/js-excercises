### f3

Cが出力され、その後Aが出力され、最後にエラーが発生した。

理由: try/catchは非同期のPromiseのエラーをキャッチできないため、errXによるエラーはキャッチされないから。  
finallyブロックは同期的に実行されるため、最初にlogCが実行される。

### f4

2秒後にAが出力され、1秒後にBが出力され、最後に100が出力された。

理由: チェーンが順番に実行され、各thenは前のthenの戻り値を次のthenへ渡す。  
最後のlog(v)でvは前のthenの戻り値である100になる。

### f5

1秒後にBが出力され、その1秒後にAが出力され、最後に40が出力された。

理由: 2つ目のthenの引数でなくPromiseになっているため、wait1()がwait2()が解決されるのを待たずに即座に実行されてしまい、Aより先にBが出力されてしまった。最後のthenでは2つ目ではなく最初のthenからの戻り値が渡され、vの値の40が出力された。

### f6

1秒後にAが出力され、その1秒後にB, その1秒後にCが出力された。

理由: 同じPromise pに対して複数のthenを呼び出すと、pの解決後にそれぞれのthenが順不同で実行されるため。
よって2つのthenは同時に開始するが、logBの待ち時間の方が1秒短いため先に出力される。

### f7

1秒後にAが出力され、その2秒後にBが出力され、その後すぐにCが出力された。

理由: pはlogA の後に解決され、wait2の後にlogBが実行され、その後logCが実行されるため。
Promiseは一度解決されるとその状態を保持し、後からthenが呼び出された場合でも、その解決値を使って登録された関数をすぐに(非同期に)実行する。

### f8

エラーXのメッセージが出力され、その後Aが出力された。

理由: errXによってエラーが発生し、catchで捕捉される。finallyは常に実行されるため、その後にlogAが実行される。

### f9

エラーYのメッセージが出力され、その後Aが出力された。

理由: thenで42を返した後、errYによってエラーが発生し、catchで捕捉される。その後、finallyでlogA が実行される。

### f10

Aが出力された後、エラーYが発生しプログラムが終了した。

理由:errYが捕捉されず適切に処理されなかったため。

### f11

エラーXのメッセージが出力された。

理由: new Promise内でerrXがthrowされると、そのエラーはPromiseのrejectによって捕捉され、catchで処理されるため。

### f12

エラーXが発生し、プログラムが終了した。

理由: errXから投げられた例外はPromiseのreject関数によって捕捉されず、未処理の例外として扱われるため。
コールバック関数内で発生した例外は、そのコールバック関数を呼び出したコードの直接的な実行フローの外にあるため、元のコールスタックには伝わらない。
